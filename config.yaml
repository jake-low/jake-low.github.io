#baseurl: http://jakelow.com/
name: Jake Low

author:
  name: Jake Low
  bio: Developer, hacker, and indomitable advocate for better software
  email: hello@jakelow.com
  phone: +1 707 540 1468
  location: Seattle, WA
  uri: https://jakelow.com
  github: https://github.com/jake-low
  gitlab: https://gitlab.com/u/jake-low
  keybase: https://keybase.io/jakelow

content:
  url: /:year/:month/:day/:title.html # default: /:section/:title.html

sections:
  # each key here is a path in /content. subpaths inherit configuration value
  # from parent paths (defaults are used if no explicit value is provided).
  # it is an error to provide a rule for a subpath, but no rule for that
  # path's parent.

  # wildcards may be used to select all sections within a parent section.

  # TODO should omitted, extant paths still be treated as sections?

  # tentative: omitted, extant paths are not treated as sections. these paths
  # may still have an effect on which template is resolved for a content item,
  # but will not be reflected in a content item's URL, and section pages will
  # not be generated for it.

  # use case: if I want /photographs to contain all of my photos, and want
  # each photo to have a URL of the form /photographs/:title, BUT I want to
  # organize my photos in the source tree by shoot name (e.g. /content/photo
  # -graphs/client-1, ../client-2, etc., I can omit those subpaths from the
  # section configuration and they won't be revealed in the generated site.

  # another use case: if I want /blog to contain all my blog-like content, but
  # I want to have different post templates for quotes, images, and essays a
  # la Tumblr, I can use /content/blog/quotes, /content/blog/images, etc. and
  # create a different template for each. If I omit the subpaths of blog from
  # this part of the config, template resolution will still work as expected,
  # but my blog won't have content URLs with the "type" encoded in them, nor
  # have a section /blog/quotes that shows all "quote-type" content.

  # a third use case: if I want to write a blog post that has other content
  # embedded (like a d3 script, images, etc.) and I wish to store that content
  # with the markdown file for the post, I can do that! Instead of naming the
  # post /content/blog/title.md, I name it /content/blog/title/index.md --
  # omitting blog/title from the config prevents creating a section for it,
  # and I can now put other content in title/ and refer to it by relative path
  # when including it in the post. (TODO convert relative to absolute URLs
  # automatically when building the site).

  # usability note: it should be illegal to include an 'index.md' or similar
  # in a path which is labelled here as a section, as this would create two
  # sources of truth on what /section should serve (one content, one template).

  # alternate: 'index.md' or similar override templates (content is king)
  # this would provide an easy way to make splash pages

  - path: essays

    # in the simple case, only a single HTML page is generated for a section.
    # however, with pagination turned on, a section /foo will be broken into
    # multiple pages e.g. /foo/page/1, /foo/page/2, etc.

    # if pagination is turned on, /foo will be created as a symlink to
    # /foo/page/1, effectively redirecting visitors in a 'URL-invisible' way.

    # TODO: how to generate splash pages (where /foo != /foo/page/1)?

    paginate: 5

    # 'sort' dictates in which order the iterator for this section yields the
    # content within it.

    sort: -date

    subsections:

      # subsections are further divisions of the content in a section. they
      # generate sub-directory URLs (such as /section/subsection), and can
      # be configured exactly like sections (pagination, sort, etc.)

      # subsections inherit their default configuration values from their
      # parent sections. for brevity, a naked 'string' key is treated the same
      # as 'path: string'

      - software
      - photography
      - travel
      - language
      - philosophy

  - path: photographs
    sort: -date
    paginate: false

  # TODO: should be able to iterate over site.sections ... how will this affect
  # dependency graph computation?

  # TODO: sections should have an order

date:
  # date is a special taxonomy; it knows how to parse ISO dates (2017-04-22) into
  # heirarchical terms, and it can restrict the 'resolution'

  # alternate idea: all taxonomies should have a 'resolution' (an int) since
  # all taxonomies can have heirarchical keys. any ISO date in the YAML should
  # be automatically converted to a heirarchy for the purpose of a taxonomy,
  # so custom dates can be used (e.g. filter movies by release date -- not
  # necessarily the same as the publish date for the content about them).

  url: /:date
  resolution: day


taxonomies:

  # each key here is the name of a taxonomy. the name determines which key is
  # retrieved from frontmatter. the key's value can be a scalar or a list of
  # scalars (the latter means the content belongs to several terms in the
  # taxonomy).

  location:
    url: /:section/loc/:term

  # tentative: taxonomies can be either "open" or "closed". the above
  # taxonomy is "open"; any term may be used in content frontmatter or
  # metadata, e.g. `location: Paris` or `location: somewhere I just made up`

  # a closed taxonomy explictly defines the set of terms that are valid.

  topic:
    url: /:section/topic/:term
    terms:
      - software
      - photography
      - travel
      - language
      - philosophy

  # topic is a closed taxonomy. using a term other than those given here (e.g.
  # marking a post with `topic: kittens`) will trigger a warning during build.

  # the advantage of a closed taxonomy is that you can define the sort order
  # of its terms. this order is used when iterating over the terms both on
  # single content (`page.topic`) and globally (`site.taxonomies.topic.terms`)

  # ---

  # additionally, a taxonomy may be either "singular" or "plural". singular
  # taxonomies are the default. a page can have no more than one value (term)
  # in a singular taxonomy, but may have any number of values (terms) in a
  # plural taxonomy.

  tags:
    url: /tags/:term
    plural: true

  # tags is an open, plural taxonomy. it is now valid for me to tag content
  # with `tags: ["foo", "bar", "baz"]`
